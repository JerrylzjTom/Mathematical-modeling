# **一次参赛，终生受益！**

## MathorCup大数据挑战赛（2023.10.27-2023.11.03）

### 总体感受

参加的第一个数模比赛，感触很多，也学得了很多。由于之前没有什么经验，我就随意拉了两个人临时组了个队伍，队里三个小白，为了能平摊200元的报名费，我还拉了个学法学的同学。这次比赛，我是建模+编程+论文一把抓，因为队里其他人都对模型不了解，编程能力也不行，但幸运的是他们都比较负责，我安排的一些边缘任务他们还是能很高效的完成，给我省了很多时间。虽说有些吃力但最后还是完成了。还好这次比赛比较简单，我一个人可以应付三人工作，但还是希望能找两个能力稍微强一些的同志，合理分工。我还发现，数学建模过程和科研过程非常像，都是建模-实验-论文，参加数学建模比赛可以很大程度提升科研能力。我还发现，在比赛期间可以短时间速成很多东西，可能平时需要花几个星期学的事情，比赛期间迫于时间，你可能一天就能学会一项技能。我在知乎上看到一篇文章，有人提问数学建模比赛有什么意义，一个人回答说：数学建模比赛，是属于高付出但不知道有没有回报的过程。因为比赛没有标准答案！学生思维就是希望事事都有标准答案，因为有了标准答案我们就有了方向，有了可以奋斗的目标，这个目标是别人给你的。但数模比赛不是的，我们可以建很多模型，我们可以从不同角度解决问题，我们没有一个确定标准答案，这就导致我们完全不知道我们的方向是不是正确的，我们花几天时间建的模型会不会拟合效果很差……。我们进入社会后是没有标准答案的，我们做的每个决策我们都不知道会使事情变好还会使事情变差，我们每天都在摸石头过河，时时刻刻经历着高投入低回报的事情，这都很正常，不要幻想人生有标准答案。我们讨厌被标准，但也喜欢标准化的东西！考研、保研、绩点、竞赛、科研、工作，我们要想好自己要做什么，自己适合做什么，不要被周围人影响，因为他们的路不一定适合你，但无论选择什么，都坚信自己选择的是正确的，不要害怕！永远不要怀着努力就一定有回报的傲慢！

### 比赛过程

赛题在27号晚6点发布，A题我看是计算机视觉的题目，因为之前没有接触过这方面知识，我就直接决定选择B题。B题是大数据处理的题目，原本以为可以使用经典的机器学习模型解决，但仔细阅读题目后，发现要用时间序列模型解决，没有接触过时间序列的相关模型，建模初期还是比较迷茫的。我看网上的思路使用LSTM和ARIMA模型的居多，所以我就决定主要使用这两个模型。LSTM之前听说过，但还没有具体研究过原理和代码，ARIMA模型是第一次听说过。我在第一天晚上就把两个模型的代码写完了，我想着明天队友把处理后的数据给我，我直接把数据导入模型，但现实是残酷的。第二天，我把数据输入到LSTM模型中，发现因为数据维度的问题，代码一直跑不起来，因为之前没有用Pytorch搭项目的经验，所以debug的根本无从下手。然后我就转战ARIMA模型，代码输进去虽说能跑起来，但不知道在跑什么，也不知道结果代表着什么。所以28-29号两天都是迷茫的，根本不知道如何处理数据和模型。30号我在知乎上看到一个思路，是将30万个数据按类别分组。真是豁然开朗。原来是没有对数据进行分析，而且也不知道数据的含义是什么，导致模型跑的数据有很大问题。我把数据分组一共有1996组数据，意味着我要用模型跑1996次。由于已经第四天了，时间紧迫，我就只在ARIMA模型跑数据，LSTM模型随便编了几个数据。数据量比较大，第一问跑一次需要两个小时，第二问比较快，第三问能跑一天！

### 收获

1. 学会了Latex的基本命令，对latex语法基本熟悉，了解了数模比赛的论文排版
2. 学习了LSTM和ARIMA两个模型
3. 了解了数模比赛的基本流程
4. 意识到团队分工合作的重要性

### 不足

1. LSTM和ARIMA模型了解不够深入，完全套用代码，一知半解
2. 数据拟合很差，本质原因还是在模型理解不够深刻，以及数据分析和处理不够深入


## 数维杯
### 总体感受
这是第一次全英文数学建模，想着为参加美赛打打基础，熟悉一下英文写作。这次比赛只有我和lkh两个人，没有再找其他队友。这次选择了一道之前没有练习过的题目，是一道关于化学反应机理的题目，做题目前花了很长时间查文献，尽量搞清楚题目的所有概念。这次的数据很少，所以传统的机器学习和深度学习模型都用不了，唉，超大数据的题目和超小数据的题目遇到我都束手无策啊，还是要多打打kaggle，多练习数据分析的能力。这次比赛总体上感觉一般，模型没有创新，第四问我觉得用微分方程做最好，但之前没有系统学习过，所以我还是采用了传统的回归拟合来做。

### 收货
1. 使用latex更加熟练
2. 学习了多项式回归模型
3. 学习了灰色预测的方法
4. 学习了方差分析和非参数估计
### 不足
1. 对小样本数据处理经验不足
2. 模型创新性不够
3. 没有用微分方程解决问题

### 代码
#### 方差分析
```python
# 方差齐性检验
from scipy.stats import levene

def Test_equal_variance(data):
    statistic, p_value = levene(data[group],center='mean')

    # 输出检验结果
    print("Levene统计量:", statistic)
    print("p值:", p_value)

    # 判断是否拒绝原假设（p值小于显著性水平，通常设为0.05）
    alpha = 0.05
    if p_value < alpha:
        print("拒绝原假设，说明四组的方差不齐")
    else:
        print("接受原假设，说明四组的方差齐性没有显著差异")

# 不服从正态分布或方差不齐使用Kruskal test
from scipy.stats import kruskal
from statsmodels.stats.multicomp import pairwise_tukeyhsd

def kruskal_test(data1, data2):

    all_data = np.concatenate([data1, data2])

    # Create labels for the groups
    labels = ['data1'] * len(data1) + ['data2'] * len(data2)
    # 判断是否存在显著差异
    kruskal_result = kruskal(data1, data2)

    # Check if there is a significant difference
    if kruskal_result.pvalue < 0.05:
        print("Kruskal-Wallis test: Reject the null hypothesis, significant difference exists")

        # Perform post hoc Tukey's HSD test
        tukey_results = pairwise_tukeyhsd(list(all_data), labels, alpha=0.05)

        # Display post hoc results
        print("Tukey's HSD post hoc test results:")
        print(tukey_results)

    else:
        print("Kruskal-Wallis test: Fail to reject the null hypothesis, no significant difference")
# 服从正态分布且方差齐性没有显著差异使用单因素方差分析

from scipy.stats import f_oneway
def ANOVA(data1, data2):
    anova_result = f_oneway(data1, data2)
    # 打印方差分析结果
    print("One-Way ANOVA p-value:", anova_result.pvalue)

    # 判断是否存在显著差异
    alpha = 0.05
    if anova_result.pvalue < alpha:
        print("One-Way ANOVA: Reject the null hypothesis, significant difference exists")
        # 将数据整合成一列
        all_data = np.concatenate([data1, data2])

        # Create labels for the groups
        labels = ['data1'] * len(data1) + [data2] * len(data2)

        # 执行 Tukey's HSD 进行事后多重比较
        tukey_results = pairwise_tukeyhsd(list(all_data), labels, alpha=alpha)

        # 显示事后多重比较结果
        print("Tukey's HSD post hoc test results:")
        print(tukey_results)

    else:
        print("One-Way ANOVA: Cannot reject the null hypothesis, no significant difference")
```
#### 堆叠图
```python
import matplotlib.pyplot as plt
import numpy as np

# data from https://allisonhorst.github.io/palmerpenguins/
import matplotlib.pyplot as plt

def stacked_bar(data):
    plt.figure(figsize=(15, 8))
    categories = data.columns.values
    # 创建堆叠图
    fig, ax = plt.subplots()

    # 绘制第一个变量的条形图，并设置label参数
    bar1 = ax.bar(categories, data[category1], label='Tar',color="#AB9A6F")

    # 绘制第二个变量的条形图，并设置bottom参数
    bar2 = ax.bar(categories, data[category2], bottom=Tar, label='Water',color="#D6E3B7")

    # 绘制第三个变量的条形图，并设置bottom参数
    bar3 = ax.bar(categories, data[category3], bottom=[i+j for i, j in zip(Tar,Water)], label='Char', color='#95A96A')

    bar4 = ax.bar(categories, data[categroy4], bottom=[i+j+k for i,j,k in zip(Tar,Water, Char)], label='Syngas', color="#45602D")
    # 添加图例
    ax.legend(loc='upper left', bbox_to_anchor=(1, 1))
    # 设置标题和轴标签
    ax.set_xlabel('data')
    ax.set_ylabel('Yields(wt.%, daf)')
    # 调整图表布局，防止注释遮挡图表内容
    plt.tight_layout()
```
#### 柱状图
```python
def bar(data1, data2, data3):
    x1 = data1.index.values
    x = np.arange(5)
    width = 0.3

    f, axs = plt.subplots(2, 3,figsize=(20, 10))
    bars1 = axs[0,0].bar(x - width, data1, width, label='data1')
    bars2 = axs[0,0].bar(x, data2, width, label='data2')
    bars3 = axs[0,0].bar(x + width, data3, width, label='data3')

    def add_labels(bars):
        for bar in bars:
            yval = bar.get_height()
            axs[0,0].text(bar.get_x() + bar.get_width()/3, yval, round(yval, 2), ha='center', va='bottom')

    add_labels(bars1)
    add_labels(bars2)
    add_labels(bars3)
    axs[0,0].set_xticks(x, x1)
    axs[0,0].set_xlabel("")
    axs[0,0].set_ylabel("")
```

#### 灰色预测
```python
class GrayForecast():
    def __init__(self, data, datacolumn=None):
    
        if isinstance(data, pd.core.frame.DataFrame):
            self.data=data
            try:
                self.data.columns = ['数据']
            except:
                if not datacolumn:
                    raise Exception('您传入的dataframe不止一列')
                else:
                    self.data = pd.DataFrame(data[datacolumn])
                    self.data.columns=['数据']
        elif isinstance(data, pd.core.series.Series):
            self.data = pd.DataFrame(data, columns=['数据'])
        else:
            self.data = pd.DataFrame(data, columns=['数据'])
    
        self.forecast_list = self.data.copy()
    
        if datacolumn:
            self.datacolumn = datacolumn
        else:
            self.datacolumn = None
        #save arg:
        #        data                DataFrame    数据
        #        forecast_list       DataFrame    预测序列
        #        datacolumn          string       数据的含义
    def level_check(self):
        # 数据级比校验
        n = len(self.data)
        lambda_k = np.zeros(n-1)
        for i in range(n-1):
            lambda_k[i] = self.data.ix[i]["数据"]/self.data.ix[i+1]["数据"]
            if lambda_k[i] < np.exp(-2/(n+1)) or lambda_k[i] > np.exp(2/(n+2)):
                flag = False
        else:
            flag = True
    
        self.lambda_k = lambda_k
    
        if not flag:
            print("级比校验失败，请对X(0)做平移变换")
            return False
        else:
            print("级比校验成功，请继续")
            return True
    
    #save arg:
    #        lambda_k            1-d list
    
    
    def GM_11_build_model(self, forecast=5):
        if forecast > len(self.data):
            raise Exception('您的数据行不够')
        X_0 = np.array(self.forecast_list['数据'].tail(forecast))
    #       1-AGO
        X_1 = np.zeros(X_0.shape)
        for i in range(X_0.shape[0]):
            X_1[i] = np.sum(X_0[0:i+1])
    #       紧邻均值生成序列
        Z_1 = np.zeros(X_1.shape[0]-1)
        for i in range(1, X_1.shape[0]):
            Z_1[i-1] = -0.5*(X_1[i]+X_1[i-1])
    
        B = np.append(np.array(np.mat(Z_1).T), np.ones(Z_1.shape).reshape((Z_1.shape[0], 1)), axis=1)
        Yn = X_0[1:].reshape((X_0[1:].shape[0], 1))
    
        B = np.mat(B)
        Yn = np.mat(Yn)
        a_ = (B.T*B)**-1 * B.T * Yn
    
        a, b = np.array(a_.T)[0]
    
        X_ = np.zeros(X_0.shape[0])
        def f(k):
            return (X_0[0]-b/a)*(1-np.exp(a))*np.exp(-a*(k))
    
        self.forecast_list.loc[len(self.forecast_list)] = f(X_.shape[0])
        
    def forecast(self, time=5, forecast_data_len=5):
        for i in range(time):
            self.GM_11_build_model(forecast=forecast_data_len)
            
    def log(self):
        res = self.forecast_list.copy()
        if self.datacolumn:
            res.columns = [self.datacolumn]
        return res
    def reset(self):
        self.forecast_list = self.data.copy()
        
        
    def plot(self, data):
        plt.scatter(data, label='Original Data', color='red')
        plt.plot(range(0,len(self.forecast_list)),self.forecast_list, label='Forecast Data')
        if self.datacolumn:
            plt.ylabel(self.datacolumn)
            plt.legend()

gf = GrayForecast(data, column)
gf.forecast(num) # 预测
gf.log() # 结果
```




